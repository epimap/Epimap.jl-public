using DataStructures, DataFrames

# Useful for converting from `DataFrame` to `Dict` which preservers column-order.
DataStructures.OrderedDict(d::DataFrame) = OrderedDict(zip(names(d), collect(eachcol(d))))

const _test_data = (
    areas = OrderedDict("area" => ["Manchester", "Salford", "Tameside", "Trafford"], "longitude" => [-2.23359, -2.38485, -2.077, -2.36572], "latitude" => [53.470089, 53.479271, 53.478668, 53.41671], "population" => [552858, 258834, 226493, 237354], "nhs_region.1" => [0, 0, 0, 0], "nhs_region.2" => [1, 1, 1, 1], "nhs_region.3" => [0, 0, 0, 0], "nhs_region.4" => [0, 0, 0, 0], "nhs_region.5" => [0, 0, 0, 0], "nhs_region.6" => [0, 0, 0, 0], "nhs_region.7" => [0, 0, 0, 0], "nhs_region.8" => [0, 0, 0, 0], "nhs_region.9" => [0, 0, 0, 0]),
    cases = OrderedDict("Country" => ["England", "England", "England", "England"], "Area name" => ["Manchester", "Salford", "Tameside", "Trafford"], "2020-01-30" => [0, 0, 0, 0], "2020-01-31" => [0, 0, 0, 0], "2020-02-01" => [0, 0, 0, 0], "2020-02-02" => [0, 0, 0, 0], "2020-02-03" => [0, 0, 0, 0], "2020-02-04" => [0, 0, 0, 0], "2020-02-05" => [0, 0, 0, 0], "2020-02-06" => [0, 0, 0, 0], "2020-02-07" => [0, 0, 0, 0], "2020-02-08" => [0, 0, 0, 0], "2020-02-09" => [0, 0, 0, 0], "2020-02-10" => [0, 0, 0, 0], "2020-02-11" => [0, 0, 0, 0], "2020-02-12" => [0, 0, 0, 0], "2020-02-13" => [0, 0, 0, 0], "2020-02-14" => [0, 0, 0, 0], "2020-02-15" => [0, 0, 0, 0], "2020-02-16" => [0, 0, 0, 0], "2020-02-17" => [0, 0, 0, 0], "2020-02-18" => [0, 0, 0, 0], "2020-02-19" => [0, 0, 0, 0], "2020-02-20" => [0, 0, 0, 0], "2020-02-21" => [0, 0, 0, 0], "2020-02-22" => [0, 0, 0, 0], "2020-02-23" => [0, 0, 0, 0], "2020-02-24" => [0, 0, 0, 0], "2020-02-25" => [0, 0, 0, 0], "2020-02-26" => [0, 0, 0, 0], "2020-02-27" => [0, 0, 0, 0], "2020-02-28" => [0, 0, 0, 0], "2020-02-29" => [0, 0, 0, 0], "2020-03-01" => [0, 0, 0, 0], "2020-03-02" => [0, 0, 0, 3], "2020-03-03" => [1, 0, 0, 0], "2020-03-04" => [1, 0, 0, 1], "2020-03-05" => [2, 0, 0, 0], "2020-03-06" => [0, 0, 1, 0], "2020-03-07" => [0, 0, 0, 0], "2020-03-08" => [0, 0, 0, 0], "2020-03-09" => [2, 0, 0, 0], "2020-03-10" => [1, 1, 1, 3], "2020-03-11" => [1, 0, 1, 0], "2020-03-12" => [0, 1, 4, 3], "2020-03-13" => [7, 2, 2, 2], "2020-03-14" => [0, 0, 2, 1], "2020-03-15" => [3, 0, 3, 2], "2020-03-16" => [6, 5, 2, 1], "2020-03-17" => [4, 2, 3, 0], "2020-03-18" => [3, 3, 3, 5], "2020-03-19" => [4, 7, 4, 4], "2020-03-20" => [4, 9, 2, 7], "2020-03-21" => [3, 8, 8, 4], "2020-03-22" => [4, 7, 4, 9], "2020-03-23" => [12, 11, 3, 5], "2020-03-24" => [9, 16, 5, 10], "2020-03-25" => [14, 6, 4, 10], "2020-03-26" => [22, 18, 8, 15], "2020-03-27" => [14, 13, 8, 8], "2020-03-28" => [31, 18, 7, 13], "2020-03-29" => [23, 14, 13, 8], "2020-03-30" => [24, 21, 10, 19], "2020-03-31" => [33, 29, 18, 13], "2020-04-01" => [28, 17, 15, 29], "2020-04-02" => [34, 21, 19, 27], "2020-04-03" => [30, 12, 13, 26], "2020-04-04" => [40, 16, 15, 16], "2020-04-05" => [36, 19, 14, 19], "2020-04-06" => [73, 33, 28, 22], "2020-04-07" => [58, 16, 10, 19], "2020-04-08" => [53, 32, 27, 31], "2020-04-09" => [63, 25, 14, 19], "2020-04-10" => [37, 29, 10, 23], "2020-04-11" => [43, 25, 8, 16], "2020-04-12" => [38, 21, 18, 12], "2020-04-13" => [40, 18, 20, 11], "2020-04-14" => [52, 28, 15, 24], "2020-04-15" => [38, 26, 17, 15], "2020-04-16" => [35, 35, 21, 24], "2020-04-17" => [15, 22, 12, 11], "2020-04-18" => [55, 36, 28, 24], "2020-04-19" => [35, 21, 13, 12], "2020-04-20" => [42, 18, 14, 23], "2020-04-21" => [39, 27, 14, 25], "2020-04-22" => [56, 28, 18, 27], "2020-04-23" => [51, 27, 15, 14], "2020-04-24" => [53, 24, 19, 17], "2020-04-25" => [35, 18, 12, 11], "2020-04-26" => [26, 21, 16, 10], "2020-04-27" => [23, 16, 17, 15], "2020-04-28" => [35, 21, 8, 15], "2020-04-29" => [50, 25, 25, 26], "2020-04-30" => [34, 19, 20, 22], "2020-05-01" => [38, 30, 28, 17], "2020-05-02" => [23, 12, 10, 14], "2020-05-03" => [29, 14, 30, 14], "2020-05-04" => [22, 10, 9, 15], "2020-05-05" => [45, 15, 18, 13], "2020-05-06" => [47, 15, 14, 11], "2020-05-07" => [38, 15, 15, 13], "2020-05-08" => [27, 10, 16, 15]),
    traffic_flux_in = OrderedDict("Column1" => ["Manchester", "Salford", "Tameside", "Trafford"], "Manchester" => [0.7277033292725058, 0.037928623518002, 0.018253731270222773, 0.06659682438300574], "Salford" => [0.028666715154159923, 0.7774315292490208, 0.0036762006392966756, 0.048530001674656986], "Tameside" => [0.026490838894242717, 0.00968326404186057, 0.8844958318444149, 0.011668075195993286], "Trafford" => [0.037517197907764664, 0.02441866584469187, 0.0048216479756421115, 0.7264389392800533]),
    distances = OrderedDict("Column1" => ["Manchester", "Salford", "Tameside", "Trafford"], "Manchester" => [0.0, 0.100953033103863, 0.104411736918246, 0.106007559573575], "Salford" => [0.100953033103863, 0.0, 0.204388369504286, 0.0707776314341651], "Tameside" => [0.104411736918246, 0.204388369504286, 0.0, 0.203844753296234], "Trafford" => [0.106007559573575, 0.0707776314341651, 0.203844753296234, 0.0]),
    traffic_flux_out = OrderedDict("Column1" => ["Manchester", "Salford", "Tameside", "Trafford"], "Manchester" => [0.868682374135854, 0.0730931794122874, 0.07719002353273612, 0.10431675893391305], "Salford" => [0.018250617699300725, 0.7990333572869097, 0.01137341992909273, 0.027368403313194636], "Tameside" => [0.006744950783022042, 0.002901473531298052, 0.7977774147545399, 0.004149919529479174], "Trafford" => [0.030930184604364953, 0.04814282513116515, 0.013227781874053502, 0.785859939162601]),
    serial_intervals = OrderedDict("Column1" => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], "fit" => [0.0183261824523828, 0.0665923069549798, 0.10191389126982, 0.11771677925845, 0.118385594423979, 0.1096347062151, 0.0961232167086674, 0.0810548507317701, 0.0663831287123141, 0.0531489564979809, 0.0417894990491873, 0.0323750573522434, 0.0247742309894593, 0.0187612758047075, 0.0140813981461474, 0.0104874277075941, 0.00775805851929146, 0.0057048545673487, 0.00417284495185088, 0.00303779925570447, 0.00220207207827872, 0.00159010774803958, 0.00114418671426919, 0.000820682873170497, 0.000586918953808024, 0.000418607884427491, 0.000297819806188371, 0.000211396110753381, 0.000149730189133779, 0.000105841261787254, 7.46778409554949e-5, 5.25983179138212e-5, 3.69864509106588e-5, 2.59685201488002e-5, 1.82064265847881e-5, 1.27470903972249e-5, 8.91331245966853e-6, 6.22499658997633e-6, 4.34249018810284e-6, 3.02596564560886e-6, 2.10638769937432e-6, 1.46481847063118e-6, 1.01770269167467e-6, 7.06429240437956e-7, 4.89942092563034e-7, 3.39520272563121e-7, 2.35096949685598e-7, 1.62668352343687e-7, 1.12472796187646e-7, 7.77128786877412e-8, 5.36601084677457e-8, 3.70283537165506e-8, 2.55359592360449e-8, 1.76000896079387e-8, 1.21236100047994e-8, 8.34665303539595e-9, 5.7433400257878e-9, 3.94999455366474e-9, 2.71528766138118e-9, 1.86564841353487e-9, 1.28128341270184e-9, 8.79566308675805e-10, 6.0353999575824e-10, 4.13964973411396e-10, 2.83822632063391e-10, 1.94518623430895e-10, 1.33263733381739e-10, 9.12647735162864e-11, 6.24800211568299e-11, 4.27590185481108e-11, 2.92530444312433e-11, 2.00064409483502e-11, 1.36783917525918e-11, 9.34896604576352e-12, 6.38800123908823e-12, 4.36350955368425e-12, 2.97972757579146e-12, 2.03426164802067e-12, 1.38844491459622e-12, 9.47464329215109e-13, 6.46260822634304e-13, 4.40758540776187e-13, 3.00426350463567e-13, 2.04947170345804e-13, 1.39555034195382e-13, 9.51461132103759e-14, 6.47260023356466e-14, 4.41868763800812e-14, 3.00870439673417e-14, 2.04281036531029e-14, 1.38777878078145e-14, 9.54791801177635e-15, 6.43929354282591e-15, 4.32986979603811e-15, 2.99760216648792e-15, 1.99840144432528e-15, 1.4432899320127e-15, 8.88178419700125e-16, 6.66133814775094e-16, 4.44089209850063e-16]),
    area_names = ["Manchester", "Salford", "Tameside", "Trafford"]
)


function _make_test_data(::typeof(Rmap.rmap_naive), data)
    # NOTE: This is only meant as a reference for how the above test data was generated.
    return map(data) do d
        if d isa DataFrame
            OrderedDict(d)
        else
            d
        end
    end
end

function get_test_data(::typeof(Rmap.rmap_naive))
    return map(_test_data) do d
        if d isa OrderedDict
            DataFrame(d)
        else
            d
        end
    end
end
